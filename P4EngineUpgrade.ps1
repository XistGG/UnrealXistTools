#!/usr/bin/env pwsh
#
# P4EngineUpgrade.ps1
#
#   Upgrade custom Unreal Engine source to a new version.
#
#   P4 is absolutely terrible at managing large sets of files.
#
#   In upgrading from UE 5.4 to UE 5.5 for example, it was a particularly large
#   set of changes:
#       - Files Added   = 52989
#       - Files Changed = 26224
#       - Files Removed = 65374
#   Attempting to `p4 reconcile` was running for 12+ hours at a time before crashing
#   and yielding no results at all.
#
#   The purpose of this script is to break the reconcile up into manageable chunks
#   that p4 can actually handle.
#
#   For this to work, you need to have the official Epic Source in a given directory,
#   AND you will need your own copy of that in a different directory,
#   AND finally we'll create a THIRD copy of the engine source in the process of
#   running this batched reconcile.
#
#   My setup is like this:
#
#   I have a dedicated "UDN Mirror" directory, which I use to sync with UDN.
#   In the case of UE 5.5, I keep it in "E:/UDN/UE_5.5" (the value I use for $EpicSrc).
#
#   I pull changes from UDN to that directory and I *NEVER* modify files in that directory.
#   This is important. *NEVER* modify the official $EpicSrc files, those are perfect mirrors
#   of UDN at all times with no deviations.
#
#   For my projects, I have my own p4 depot `//Xim/Engine` which is the version of the engine
#   that I'm currently using.  Other projects then are like `//Xim/Project1` which use the
#   engine as a parent stream, so once I copy the new Epic source into //Xim/Engine, I can
#   then easily integrate it into my projects.
#
#   The "XimEngine54_xist" workspace is on my own p4 server, its the 5.4 version of
#   my local engine source, with no changes at all (it should be an exact mirror of Epic's UE 5.4,
#   as last sync'd by me to UDN).
#
#   Example command line:
#
#       P4EngineUpgrade.ps1
#           -EpicSrc "E:/UDN/UE_5.5"
#           -MySrc "E:/XimEngine/XE_5.4"
#           -MyWorkspace "XimEngine54_xist"
#           -Reset
#           -Diff
#           -P4
#
#   The -Reset flag totally nukes the $NewSrc temporary directory, if it exists, and resets it
#   to a good starting value.
#
#   The -Diff flag compares $EpicSrc and $MySrc to determine what the diffs are, and records the
#   lists of added, changed and removed files in temp files in $NewSrc.
#
#   The -P4 flag uses the temp files (generated by -Diff) to create multiple p4 changelists
#   batching together the add/edit/delete operations into batches of max size $BatchSize, which
#   should be large enough to not be annoying, and small enough that p4 doesn't crash.
#
#   After running this, there will be a new workspace named "${MyWorkspace}_temp" which will have
#   a number of pending changelists for you to review.  The workspace root will be $NewSrc.
#
#   You can break this up into different executions, particularly useful when debugging or testing
#   this script, like:
#
#       First run :  P4EngineUpgrade.ps1 -Reset %ARGS%
#       Second run:  P4EngineUpgrade.ps1 -Diff %ARGS%
#       Third run :  P4EngineUpgrade.ps1 -P4 %ARGS
#
#   In the 3 runs above, %ARGS% should be consistent arguments setting EpicSrc, MySrc, MyWorkspace
#   and any other args you want to change.
#

[CmdletBinding()]
param(
    [switch]$Diff,
    [switch]$Help,
    [switch]$P4,
    [switch]$Reset,
    [Parameter()]$EpicSrc="C:/Source/EpicNewSource",
    [Parameter()]$MySrc="C:/Source/MyCurrentSource",
    [Parameter()]$NewSrc="C:/Temp/P4EngineUpgrade",
    [Parameter()]$MyWorkspace="OldEngineVersionWorkspace",
    [Parameter()]$TempFilePrefix=".P4EngineUpgrade",
    [Parameter()]$HashAlgorithm="SHA512",
    [Parameter()]$BatchSize=10000,
    [Parameter()]$BucketSize=50,
    [Parameter()][int]$MaxDepth=-1  # -1 means no maximum
)

# Make sure the powershell version is good, or throw an exception
& $PSScriptRoot/PSVersionCheck.ps1

# Import the P4 helper module
Import-Module -Name $PSScriptRoot/Modules/P4.psm1

$ScriptName = $MyInvocation.MyCommand.Name

$MyTempWorkspace = "${MyWorkspace}_temp"

$Stats = @{
    Added = 0
    Changed = 0
    Removed = 0
    Unchanged = 0
    Skipped = 0
}


function GetHelpOutput()
{
    $FullPathDisplay = $SyncFileItem ? "`"$($SyncFileItem.FullName)`"" : "NO_SUCH_FILE"
    return @"

############################################################
##
##  Usage for ${ScriptName}:
##

TODO MAKE USAGE OUTPUT!

For now, read the comments at the top of the script:
${PSScriptRoot}/${ScriptName}

"@
}

if ($Help)
{
    return &GetHelpOutput
}


################################################################################
##
################################################################################

function CheckArgs
{
    # Make sure the $MySrc directory exists

    if ($MySrc -eq "" -or -not (Test-Path -Path $MySrc -PathType Container))
    {
        throw "Invalid parameter MySrc is not a valid directory ($MySrc)"
    }

    # Convert $MySrc into an absolute path
    $item = Get-Item -LiteralPath $MySrc
    $MySrc = $item.FullName

    # Make sure the $EpicSrc directory exists

    if ($EpicSrc -eq "" -or -not (Test-Path -LiteralPath $EpicSrc -PathType Container))
    {
        throw "Invalid parameter EpicSrc is not a valid directory ($EpicSrc)"
    }

    # Configure temp file names
    $script:TempFilenameAdded = Join-Path $NewSrc "$TempFilePrefix.added"
    $script:TempFilenameChanged = Join-Path $NewSrc "$TempFilePrefix.changed"
    $script:TempFilenameRemoved = Join-Path $NewSrc "$TempFilePrefix.removed"
}

function ResetTempP4Workspace
{
    # Check to see if the temp workspace exists.  If so, prompt to delete it.
    if (p4 client --exists -o $MyTempWorkspace 2> $null)
    {
        $response = Read-Host "Temporary P4 workspace exists ($MyTempWorkspace). Delete it? (y|N) [N] "
        $confirmed = $response -ieq 'y'

        if (-not $confirmed)
        {
            Write-Error "Please delete the temporary P4 workspace ($MyTempWorkspace) and try again"
            throw "Operation cancelled so as not to clobber an existing P4 workspace"
        }

        # User confirmed, delete the temp workspace
        try {
            # Get a list of all pending changelists (e.g. from previous failed attempts at this script)
            $pendingCLs =& P4_GetPendingChangeLists -Workspace $MyTempWorkspace

            # Totally nuke all of these CLs.
            # This doesn't change the files in the workspace at all, it just deletes the CLs
            # so we can delete the workspace.
            foreach ($clNum in $pendingCLs)
            {
                p4 revert -k -c $clNum //...
                p4 change -d $clNum
            }

            p4 client -d $MyTempWorkspace
        } catch {
            throw "Failed to remove temporary P4 workspace `"$MyTempWorkspace`": $_"
        }
    }

    # Create a temporary P4 workspace
    try {
        # Get the stream from $MyWorkspace since P4 is stupid and won't keep it when copying from another workspace
        $streamLine = p4 client -o $MyWorkspace | Select-String -Pattern '^Stream:'
        $streamLine -imatch '^Stream:\s+(.*)'
        $stream = $matches[1]

        if (-not $stream)
        {
            Write-Error "A stream workspace is required."
            throw "Failed to obtain Stream definition from existing workspace `"$MyWorkspace`""
        }

        # Read current workspace definition
        $workspaceDef = p4 client -o -S $stream $MyTempWorkspace

        # Perform regexp modifications to use new workspace name and directory
        $workspaceDef = $workspaceDef `
            -replace '^Root:.*', "Root: $NewSrc"

        # Create new workspace
        $workspaceDef | p4 client -i
    } catch {
        throw "Failed to create temp P4 workspace: $_"
    }
}

function InitTempFileWriters()
{
    try
    {
        $script:TempAddedWriter = [System.IO.StreamWriter]::new($TempFilenameAdded)
        $script:TempChangedWriter = [System.IO.StreamWriter]::new($TempFilenameChanged)
        $script:TempRemovedWriter = [System.IO.StreamWriter]::new($TempFilenameRemoved)
    }
    catch
    {
        throw "Error initializing temp status files: $_"
    }
}

function InitTempFileReaders()
{
    try
    {
        $script:TempAddedReader = [System.IO.StreamReader]::new($TempFilenameAdded)
        $script:TempChangedReader = [System.IO.StreamReader]::new($TempFilenameChanged)
        $script:TempRemovedReader = [System.IO.StreamReader]::new($TempFilenameRemoved)
    }
    catch
    {
        throw "Error initializing temp status files: $_"
    }
}

function ResetNewSrcDir()
{
    # Convert $EpicSrc into an absolute path
    $item = Get-Item -LiteralPath $EpicSrc
    $EpicSrc = $item.FullName

    # Make sure $NewSrc directory does not already exist.
    # If it does exist, nuke it (or prompt to if not -Force)

    if ($NewSrc -eq "")
    {
        throw "New Engine Source dir NewSrc must be set via parameters"
    }

    if (Test-Path -Path $NewSrc)
    {
        # Convert $NewSrc into an absolute path
        $item = Get-Item -LiteralPath $NewSrc
        $NewSrc = $item.FullName

        # Prompt user to determine if the existing directory should be deleted
        $response = Read-Host "New Source Directory exists ($NewSrc). Delete it? (y|N) [N] "
        $confirmed = $response -ieq 'y'

        if (-not $confirmed)
        {
            Write-Error "To successfully upgrade Unreal Engine, choose a NewSrc path that does not yet exist."
            throw "Operation cancelled, please manually remove the directory `"$NewSrc`" or choose another directory."
        }

        # User has confirmed they want to nuke the directory, do so now
        try {
            Remove-Item -Force -Recurse -LiteralPath $NewSrc
            Write-Debug "Deleted previous NewSrc directory: $NewSrc"
        } catch {
            throw "Failed to remove directory ($NewSrc): $_"
        }
    }

    # Create a new empty $NewSrc directory

    try {
        $item = New-Item -ItemType Directory -Path $NewSrc

        # Convert $NewSrc into an absolute path
        $NewSrc = $item.FullName

        Write-Debug "Created NewSrc directory: $NewSrc"
    } catch {
        throw "Failed to create directory ($NewSrc): $_"
    }
}

function CloseTempFiles()
{
    if ($TempAddedWriter)
    {
        $TempAddedWriter.Dispose()
        $TempAddedWriter = $null
    }

    if ($TempChangedWriter)
    {
        $TempChangedWriter.Dispose()
        $TempChangedWriter = $null
    }

    if ($TempRemovedWriter)
    {
        $TempRemovedWriter.Dispose()
        $TempRemovedWriter = $null
    }

    if ($TempAddedReader)
    {
        $TempAddedReader.Dispose()
        $TempAddedReader = $null
    }

    if ($TempChangedReader)
    {
        $TempChangedReader.Dispose()
        $TempChangedReader = $null
    }

    if ($TempRemovedReader)
    {
        $TempRemovedReader.Dispose()
        $TempRemovedReader = $null
    }
}

function TestIdenticalItems()
{
    [cmdletBinding()]
    param(
        [string] $ItemName,
        [IO.FileInfo] $Item1,
        [IO.FileInfo] $Item2
    )

    if (-not $Item1 -or -not $Item2 -or -not $Item1.Exists -or -not $Item2.Exists)
    {
        throw "Programmer error: Don't process null or non-existing items"
    }

    # If the file items have different lengths (file sizes) then we know they're different
    if ($Item1.Length -ne $Item2.Length)
    {
        Write-Verbose "Detected file size diff for `"$ItemName`""
        return $false
    }

    try
    {
        $hash1 = Get-FileHash -LiteralPath $Item1.FullName -Algorithm $HashAlgorithm
        $hash2 = Get-FileHash -LiteralPath $Item2.FullName -Algorithm $HashAlgorithm

        # True if the hashes are identical; else False
        $result = $hash1.Hash -eq $hash2.Hash
    }
    catch
    {
        throw "Error comparing `"$ItemName`" hashes: $_"
    }

    return $result
}

function GetRelativePath()
{
    [cmdletBinding()]
    param(
        [string] $RootPath,
        [string] $ChildPath
    )

    # Make sure $ChildPath is a child of $RootPath
    $subPath = $ChildPath.Substring(0, $RootPath.Length)
    if ($RootPath -ne $subPath)
    {
        Write-Error "Found a child path ($ChildPath) outside its expected root ($RootPath)"
        Write-Debug "RootPath=`"$RootPath`""
        Write-Debug "ChildPath=`"$ChildPath`""
        Write-Debug "substring=`"$subPath`""
        throw "Programmer error, path mismatch"
    }

    $relPath = $ChildPath.Substring($RootPath.Length)

    if ($relPath.Length -gt 0)
    {
        # Remove however many leading directory separator chars there are in this string
        $c = [System.IO.Path]::DirectorySeparatorChar
        $i = 0
        while ($i -lt $relPath.Length -and $relPath[$i] -eq $c)
        {
            $i++
        }
        $relPath = $relPath.Substring($i)
    }

    return $relPath
}

function MakeRelativeChildPath()
{
    [cmdletBinding()]
    param(
        [string] $RelativeDirPath,
        [string] $ChildName
    )

    if ($RelativeDirPath -eq "")
    {
        return $ChildName
    }

    $result = Join-Path -Path $RelativeDirPath -ChildPath $ChildName
    return $result
}

function ScanDirectory()
{
    [cmdletBinding()]
    param(
        [string] $Directory
    )

    $result = New-Object System.Collections.ArrayList

    if ($Directory -eq "" -or -not (Test-Path -LiteralPath $Directory -PathType Container))
    {
        Write-Warning "ScanDirectory requested for empty or non-existing directory ($Directory)"
        return $result  # return empty result
    }

    # Get ALL listings, even hidden ones, but NOT recursively, we just want this one directory
    try {
        $result = Get-ChildItem -LiteralPath $Directory -Force
        return $result
    } catch {
        throw "Error listing directory `"$Directory`": $_"
    }
}

function ScanEpicSrcDir()
{
    [cmdletBinding()]
    param(
        [string] $Directory = $EpicSrc,
        [int] $CurrentDepth = 0
    )

    # Determine the relative path inside $EpicSrc for $MySrc comparisons

    $rootItem = Get-Item -LiteralPath $EpicSrc
    $thisItem = Get-Item -LiteralPath $Directory

    # Determine the relative path for the current directory.
    # In $EpicSrc dir, this will be ""
    # In all its child dirs, this will be non-""
    $relPath =& GetRelativePath -RootPath $rootItem.FullName -ChildPath $thisItem.FullName

    Write-Debug "Scan [$CurrentDepth] `"$($thisItem.FullName)`" (relative path: `"$relPath`")"
    $children = &ScanDirectory -Directory $thisItem.FullName

    foreach ($child in $children)
    {
        $childRelPath =& MakeRelativeChildPath -RelativeDirPath $relPath -ChildName $child.Name

        # If the child is a directory, we need to scan it too
        if ($child -is [System.IO.DirectoryInfo])
        {
            if ($MaxDepth -lt 0 -or $CurrentDepth -le $($MaxDepth-1))
            {
                # Found a directory that isn't too deep to process, so recurse into it
                ScanEpicSrcDir -Directory $child.FullName -CurrentDepth $(1+$CurrentDepth)
            }
            else
            {
                $Stats.Skipped += 1
            }
        }
        else
        {
            # This is a file in a directory we are processing

            # If this file doesn't exist in $MySrc then it's new in this UE version

            $myPath = Join-Path -Path $MySrc -ChildPath $childRelPath
            $myItem = Get-Item -LiteralPath $myPath 2> $nul

            if (-not $myItem -or -not $myItem.Exists)
            {
                # NEW FILE in $EpicSrc not found in $MySrc

                Write-Debug "NEW File `"$childRelPath`" (at `"$($child.FullName)`")"

                $TempAddedWriter.WriteLine($childRelPath)
                $Stats.Added += 1
            }
            else
            {
                # This file exists both in $MySrc and in $EpicSrc
                # We'll keep it, the question is whether it has changed or not

                if (TestIdenticalItems -ItemName $childRelPath -Item1 $myItem -Item2 $child)
                {
                    # The contents of these 2 items are identical

                    Write-Debug "Identical File `"$childRelPath`" (at `"$($child.FullName)`")"

                    $Stats.Unchanged += 1
                }
                else
                {
                    # The contents of this file in our custom engine differs from the Epic version

                    Write-Debug "MODIFIED File `"$childRelPath`" (at `"$($child.FullName)`")"

                    $TempChangedWriter.WriteLine($childRelPath)
                    $Stats.Changed += 1
                }
            }
        }
    }

    $TempAddedWriter.Flush()
    $TempChangedWriter.Flush()
}

function ScanMySrcDir()
{
    [cmdletBinding()]
    param(
        [string] $Directory = $MySrc,
        [int] $CurrentDepth = 0
    )

    # Determine the relative path inside $MySrc for $EpicSrc comparisons

    $rootItem = Get-Item -LiteralPath $MySrc
    $thisItem = Get-Item -LiteralPath $Directory

    # Determine the relative path for the current directory.
    # In $MySrc dir, this will be ""
    # In all its child dirs, this will be non-""
    $relPath =& GetRelativePath -RootPath $rootItem.FullName -ChildPath $thisItem.FullName

    Write-Debug "Scan [$CurrentDepth] `"$($thisItem.FullName)`" (relative path: `"$relPath`")"
    $children = &ScanDirectory -Directory $thisItem.FullName

    foreach ($child in $children)
    {
        $childRelPath =& MakeRelativeChildPath -RelativeDirPath $relPath -ChildName $child.Name

        # If the child is a directory, we need to scan it too
        if ($child -is [System.IO.DirectoryInfo])
        {
            if ($MaxDepth -lt 0 -or $CurrentDepth -le $($MaxDepth-1))
            {
                # Found a directory that isn't too deep to process, so recurse into it
                ScanMySrcDir -Directory $child.FullName -CurrentDepth $(1+$CurrentDepth)
            }
            else
            {
                $Stats.Skipped += 1
            }
        }
        else
        {
            # This is a file in a directory we are processing

            # If this file doesn't exist in $EpicSrc then it has been removed in the new UE version

            $epicPath = Join-Path -Path $EpicSrc -ChildPath $childRelPath
            $epicItem = Get-Item -LiteralPath $epicPath 2> $nul

            if (-not $epicItem -or -not $epicItem.Exists)
            {
                # REMOVED FILE in $EpicSrc compared to previous $MySrc

                Write-Debug "REMOVED File `"$childRelPath`" (at `"$($child.FullName)`")"

                $TempRemovedWriter.WriteLine($childRelPath)
                $Stats.Removed += 1
            }
            # else we already handled files that exist in both, whether or not they changed
        }
    }

    $TempRemovedWriter.Flush()
}

function ShowDiffStats()
{
    $total = $Stats.Added + $Stats.Changed + $Stats.Removed + $Stats.Unchanged

    Write-Host "Finished comparing $total files ($($Stats.Added) new, $($Stats.Changed) changed, $($Stats.Removed) removed)"

    if ($Stats.Skipped -gt 0)
    {
        Write-Warning "Skipped $($Stats.Skipped) directory trees due to MaxDepth=$MaxDepth; increase it to process all files"
    }
}

function InitNewSrcContents
{
    # Copy the current state of our own source ($MySrc) into the new source
    # location ($NewSrc) so we don't have to slow sync it from p4.

    Write-Debug "Copying `"$MySrc`" content into `"$NewSrc`""
    try {
        cp -Force -Recurse $MySrc/* $NewSrc
    } catch {
        throw "Failed to copy `"$MySrc`" content to `"$NewSrc`": $_"
    }
}

function CreateDirectoryIfNeeded
{
    [CmdletBinding()]
    param(
        [string] $Path
    )

    if (-not (Test-Path -Path $Path))
    {
        $parentPath = Split-Path -Path $Path -Parent
        CreateDirectoryIfNeeded -Path $parentPath

        try {
            New-Item -Path $Path -ItemType Directory > $null
        } catch {
            throw "Failed to create directory `"$Path`": $_"
        }
    }
}

function CopyEpicFile
{
    [CmdletBinding()]
    param(
        [string] $RelativePath
    )

    $srcPath = Join-Path $EpicSrc $RelativePath
    $dstPath = Join-Path $NewSrc $RelativePath

    $dstParentDir = Split-Path -Path $dstPath -Parent
    CreateDirectoryIfNeeded -Path $dstParentDir

    try {
        # MUST use -LiteralPath for the $srcPath so filenames like "[foo]" aren't interpreted as wildcards!
        Copy-Item -Force -LiteralPath $srcPath -Destination $dstPath
    } catch {
        throw "Failed to copy Epic file `"$srcPath`" into `"$dstPath`": $_"
    }
}

function SyncP4HaveList
{
    # Sync ONLY the "have list" with P4 so we don't have to download all the content
    # over the network.  (We already have it locally).

    Write-Host "Syncing workspace have-list..."
    try {
        cd $NewSrc

        # force use of the temp workspace for this operation
        $env:P4CLIENT = $MyTempWorkspace

        $output = p4 sync -k --parallel=threads=8 ... > .p4sync.txt

    } catch {
        throw "Failed to sync P4 have list for `"$MyTempWorkspace`": $_"
    }
}

function CreateP4Changelist
{
    [CmdletBinding()]
    param(
        [string] $Description
    )

    #PS C:\Temp\P4EngineUpgrade> p4 --field "Description=Test" change -o | p4 change -i
    #Change 65 created.

    $result = $(p4 --field "Description=$Description" change -o | p4 change -i)

    if ($result -imatch '^\s*Change\s+(\d+)\s+created')
    {
        $cl = $matches[1]
        return $cl
    }

    throw "Failed to create a new P4 CL: $result"
}

function ExecP4Command
{
    [CmdletBinding()]
    param(
        [string] $Command,
        [System.Collections.ArrayList] $CommandArgs,
        [System.Collections.ArrayList] $Paths
    )

    # Make sure to remove any paths that are supposed to be ignored, p4 refuses to process them
    # and returns an error if we include them on the command line.
    $p4ignoreResult =& P4_FilterIgnoredPaths -Paths $Paths

    if ($p4ignoreResult.ValidPaths.Count -eq 0)
    {
        # ALL of the paths are ignored.
        # Don't execute p4 at all in this case
        return
    }

    $args = New-Object System.Collections.ArrayList
    $args.Add($Command) > $null

    foreach ($arg in $CommandArgs)
    {
        $args.Add($arg) > $null
    }

    # Add NON-IGNORED PATHS ONLY as quoted arguments
    foreach ($Path in $p4ignoreResult.ValidPaths)
    {
        # Must first P4-encode the path so it doesn't croak on special filename characters
        $encoded =& P4_EncodePath -Path $path
        # Secondarily shell-escape any double quote characters in the path
        $escaped = $encoded -replace '"', '`"'
        # Finally encase it all in double quotes in case there are spaces in the name
        $args.Add("`"$escaped`"") > $null
    }

    try {
        Write-Debug "EXEC: p4 $($args -join ' ')"
        $process = Start-Process -NoNewWindow -PassThru -FilePath "p4" -ArgumentList $args
    } catch {
        throw "Failed to execute p4 ${Command}: $_"
    }

    Wait-Process -InputObject $process
    $e = $process.ExitCode

    if ($e -ne 0)
    {
        throw "p4 $Command failed: (exit code $e)"
    }
}

function BatchP4Adds
{
    Write-Host "Batching p4 adds..."

    $cl = $null
    $bucket = New-Object System.Collections.ArrayList
    $batchCount = 0
    $batchId = 1

    # Always make sure we're working on the temp workspace from its root directory
    $env:P4CLIENT = $MyTempWorkspace
    cd $NewSrc

    while (($line = $TempAddedReader.ReadLine()) -ne $null)
    {
        $relPath = $line.Trim()  # In case there is trailing nonsense

        # Copy the newly added file from $EpicSrc into $NewSrc
        CopyEpicFile -RelativePath $relPath

        $bucket.Add($relPath) > $null

        if ($bucket.Count -ge $BucketSize)
        {
            if ($cl -eq $null)
            {
                $cl = &CreateP4Changelist -Description "${ScriptName}: Add batch $batchId"
            }

            $args = @("-c", $cl, "-f")
            ExecP4Command -Command "add" -CommandArgs $args -Paths $bucket
            $batchCount += $bucket.Count

            $bucket.Clear()

            if ($batchCount -ge $BatchSize)
            {
                # Stop adding to this changelist, create a new one if needed
                $cl = $null
                $batchCount = 0
                $batchId += 1
            }
        }
    }

    # Finish adding any remaining files to p4
    if ($bucket.Count -gt 0)
    {
        if ($cl -eq $null)
        {
            $cl = &CreateP4Changelist -Description "${ScriptName}: Add batch $batchId"
        }

        $args = @("-c", $cl, "-f")
        ExecP4Command -Command "add" -CommandArgs $args -Paths $bucket
    }
}

function BatchP4Deletes
{
    Write-Host "Batching p4 deletes..."

    $cl = $null
    $bucket = New-Object System.Collections.ArrayList
    $batchCount = 0
    $batchId = 1

    # Always make sure we're working on the temp workspace from its root directory
    $env:P4CLIENT = $MyTempWorkspace
    cd $NewSrc

    while (($line = $TempRemovedReader.ReadLine()) -ne $null)
    {
        $relPath = $line.Trim()  # In case there is trailing nonsense

        $bucket.Add($relPath) > $null

        if ($bucket.Count -ge $BucketSize)
        {
            if ($cl -eq $null)
            {
                $cl = &CreateP4Changelist -Description "${ScriptName}: Remove batch $batchId"
            }

            $args = @("-c", $cl)
            ExecP4Command -Command "delete" -CommandArgs $args -Paths $bucket
            $batchCount += $bucket.Count

            $bucket.Clear()

            if ($batchCount -ge $BatchSize)
            {
                # Stop adding to this changelist, create a new one if needed
                $cl = $null
                $batchCount = 0
                $batchId += 1
            }
        }
    }

    # Finish adding any remaining files to p4
    if ($bucket.Count -gt 0)
    {
        if ($cl -eq $null)
        {
            $cl = &CreateP4Changelist -Description "${ScriptName}: Remove batch $batchId"
        }

        $args = @("-c", $cl)
        ExecP4Command -Command "delete" -CommandArgs $args -Paths $bucket
    }
}

function BatchP4Edits
{
    Write-Host "Batching p4 edits..."

    $cl = $null
    $bucket = New-Object System.Collections.ArrayList
    $batchCount = 0
    $batchId = 1

    # Always make sure we're working on the temp workspace from its root directory
    $env:P4CLIENT = $MyTempWorkspace
    cd $NewSrc

    while (($line = $TempChangedReader.ReadLine()) -ne $null)
    {
        $relPath = $line.Trim()  # In case there is trailing nonsense

        # Copy the newly added file from $EpicSrc into $NewSrc
        CopyEpicFile -RelativePath $relPath

        $bucket.Add($relPath) > $null

        if ($bucket.Count -ge $BucketSize)
        {
            if ($cl -eq $null)
            {
                $cl = &CreateP4Changelist -Description "${ScriptName}: Edit batch $batchId"
            }

            $args = @("-c", $cl)
            ExecP4Command -Command "edit" -CommandArgs $args -Paths $bucket
            $batchCount += $bucket.Count

            $bucket.Clear()

            if ($batchCount -ge $BatchSize)
            {
                # Stop adding to this changelist, create a new one if needed
                $cl = $null
                $batchCount = 0
                $batchId += 1
            }
        }
    }

    # Finish adding any remaining files to p4
    if ($bucket.Count -gt 0)
    {
        if ($cl -eq $null)
        {
            $cl = &CreateP4Changelist -Description "${ScriptName}: Edit batch $batchId"
        }

        $args = @("-c", $cl)
        ExecP4Command -Command "edit" -CommandArgs $args -Paths $bucket
    }
}


################################################################################
##  Main Procedure
################################################################################

&CheckArgs

# Using a static copy of the current state of our own source ($MySrc),
# and a static copy of the new state of Epic's source ($EpicSrc),
# compare the two to determine the diffs.
#
# Store the results in temp files that we can read later.

try
{
    if ($P4 -and $Reset)
    {
        # We want to do this right away in the event of a full run, since it may
        # require attention from the user, so don't wait hours before asking questions.
        &ResetTempP4Workspace
    }

    if ($Reset)
    {
        # Nuke $NewSrc and reset it by copying $MySrc/* into it so we have an exact mirror
        &ResetNewSrcDir
        &InitNewSrcContents
    }

    if ($Diff)
    {
        &InitTempFileWriters
        &ScanEpicSrcDir  # look for new/changed files
        &ScanMySrcDir  # look for removed files
        &CloseTempFiles

        # Need to sync the p4 have list any time we perform a diff (which modifies files in $NewSrc)
        &SyncP4HaveList

        &ShowDiffStats
    }

    if ($P4)
    {
        &InitTempFileReaders
        &BatchP4Adds
        &BatchP4Deletes
        &BatchP4Edits
        &CloseTempFiles
    }
}
finally
{
    &CloseTempFiles
}
